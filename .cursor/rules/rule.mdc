---
description: 
globs: 
alwaysApply: true
---
아래는 플샵(PPLShop) 프로젝트에 맞춰 기존 FMG 프로젝트 가이드를 React Native + 웹 기반 환경으로 업데이트한 개발 표준(“Cursor Rule”) 예시입니다. 원문의 Must / Should / May 체계를 유지하면서, 멀티 에이전트(Agent AI) 협업을 포함하는 형태로 재구성했습니다.

⸻

플샵(PPLShop) 프로젝트 개발 표준 가이드 (Cursor Rule) 1.0

개요: RN+웹 환경 & 멀티 에이전트 협업 중심

이 문서는 플샵(PPLShop) 프로젝트의 React Native(모바일 앱) + React/Next.js(웹) 개발 표준을 제시합니다. 기존 FMG 가이드를 기반으로, 프로젝트 규모와 특성, 그리고 멀티 에이전트 AI 협업(PM, Designer, Frontend, Backend, AI Engineer 등) 시나리오를 고려하여 작성했습니다.

이 문서의 사용법
	1.	새 프로젝트 시작 시:
	•	핵심 원칙(Must) 반드시 적용
	•	권장 사항(Should) 중 프로젝트 특성에 맞는 항목 선택
	•	선택 사항(May) 팀 상황에 따라 적용 검토
	2.	기존 프로젝트 개선 시:
	•	핵심 원칙부터 우선 적용
	•	필요 시 권장·선택 사항 단계적으로 도입
	3.	에이전트 협업 시:
	•	PM Agent가 프로젝트 구조, 코드 품질, MCP(툴 연동) 관련 Must 규칙 준수를 주도
	•	다른 역할별 에이전트(Designer, Frontend, Backend, AIEngineer)도 코드 생성, 폴더 구조, 파일 명명 시 본 가이드 준수

⸻

핵심 원칙 요약 (Core Rules)

1. 프로젝트 구조 (Must)
	1.	표준 폴더 구조 준수:
	•	React Native 앱: app/{screens,components,services,config}, assets/
	•	웹(React/Next.js): src/{pages,components,services,config}, public/
	•	목적: 코드 탐색과 협업 효율성 향상
	•	적용: 모든 규모 프로젝트에 필수
	2.	기능별 분리 원칙: UI, 비즈니스 로직, 데이터 접근 코드 분리
	•	목적: 코드 재사용성과 테스트 용이성
	•	적용: RN과 웹 모두 적용. 모놀리식 혼합 금지
	3.	일관된 파일명 규칙:
	•	RN: MainScreen.js, LoginComponent.js 등
	•	웹: MainPage.jsx, UserCardComponent.jsx 등
	•	목적: 파일 탐색/용도 파악 용이성
	•	적용: 다수 개발자 참여 시 필수

2. 디자인 시스템 (Must)
	4.	상수/테마 파일 사용:
	•	colors.js, typography.js, spacing.js 등
	•	목적: UI 일관성, 테마 변경 용이성
	•	적용: 하드코딩된 색/폰트/크기 값 사용 금지
	5.	공통 컴포넌트 우선: 기존 재사용 가능 컴포넌트 우선 활용, 중복 구현 지양
	•	목적: 코드 중복 방지, UI 일관성 유지
	•	적용: RN/웹 모두 컴포넌트 카탈로그 관리

3. 코드 품질 (Must)
	6.	의미 있는 네이밍: 변수, 함수, 클래스 명은 역할을 명확히 반영
	•	목적: 코드 가독성·유지보수성 향상
	•	적용: 무의미한 약어/축약 사용 금지
	7.	상태 관리 일관성:
	•	React Native/웹 모두 Redux Toolkit or React Query or Context 등 한 가지 패턴
	•	목적: 예측 가능성·디버깅 용이성
	•	적용: 혼합 사용 지양

4. 협업 및 문서화 (Must)
	8.	오류 및 작업 기록: errorlog.md, worklog.md에 주요 오류와 해결책 기록
	•	목적: 지식 공유 및 반복 오류 방지
	•	적용: 모든 중요 이슈 문서화
	9.	문서-코드 동기화: 코드 변경 시 관련 문서 갱신
	•	목적: 문서 신뢰성 유지
	•	적용: API·공통 컴포넌트 변경 시 필수
	10.	코드 리뷰 준수: 모든 프로덕션 코드는 최소 1인 이상 리뷰 후 병합
	•	목적: 코드 품질·팀 지식 공유
	•	적용: 긴급 수정도 가능한 한 리뷰

⸻

1. 프로젝트 구조 표준

1.1 React Native 앱 구조 (Must)

my-rn-app/
├── app/
│   ├── screens/         # 화면 (HomeScreen.js, LoginScreen.js 등)
│   ├── components/      # 재사용 위젯 (UserCard.js, CommonButton.js)
│   ├── services/        # API, 상태 관리 모듈
│   ├── config/          # 환경설정 (env 등)
│   ├── App.js           # 앱 진입점
│   └── index.js         # 런처(선택)
├── assets/
│   ├── images/
│   ├── svg/
│   └── fonts/
└── package.json

	•	목적: RN 앱에서 스크린/컴포넌트/서비스를 분리해 유지보수성↑
	•	맥락: 소규모 앱도 최소 screens, components 분리 권장

1.2 웹(React/Next.js) 구조 (Must)

my-web-app/
├── src/
│   ├── pages/            # Next.js 페이지 라우팅 (index.jsx, login.jsx 등)
│   ├── components/       # UI 컴포넌트
│   ├── services/         # API, 비즈니스 로직
│   ├── config/           # 환경설정
│   └── index.js          # 앱 진입 (CRA 또는 _app.js / _document.js - Next.js)
├── public/               # 정적 파일
└── package.json

	•	목적: Next.js/CRA 환경에서 pages 폴더(Next.js) 혹은 별도 router 구조(React Router) 구분
	•	맥락: 재사용 컴포넌트는 components/, API·비즈니스 로직은 services/

1.3 아키텍처별 변형 (May)
	•	Redux: store/, reducers/, actions/ 폴더 추가
	•	Clean Architecture: React Native/웹에서 “domain / data / presentation” 구조
	•	목적: 팀 선호도와 프로젝트 규모에 맞춰 설계

⸻

2. 파일명 규칙

React Native 파일명 (Must)
	•	화면(Screens): {기능명}Screen.js (예: MainScreen.js, LoginScreen.js)
	•	컴포넌트: {기능명}Component.js or {기능명}View.js (예: UserCardComponent.js)
	•	서비스: {기능명}Service.js (예: authService.js)
	•	목적: 역할별 파일 명시적 구분

웹 파일명 (Must)
	•	Next.js 페이지: {기능명}.jsx (예: login.jsx, index.jsx)
	•	컴포넌트: {기능명}Component.jsx (예: UserProfileComponent.jsx)
	•	서비스/로직: {기능명}Service.js
	•	목적: 코드 탐색 용이성

상수/테마 (Must)
	•	colors.js, typography.js, spacing.js, globalStyles.js 등
	•	목적: 앱 전체 스타일을 한 곳에서 관리

에셋 (Should)
	•	이미지: {유형}_{이름}.{png/jpg} (예: icon_login.png)
	•	SVG: {유형}_{이름}.svg
	•	목적: 파일 용도 파악 및 검색 용이

⸻

3. 디자인 시스템 구현

3.1 색상 / 텍스트 스타일 (Must)

// colors.js
export const Colors = {
  primary: '#3A86FF',
  secondary: '#8338EC',
  background: '#F8F9FA',
  textPrimary: '#212529',
  // ...
};

// typography.js
export const Typography = {
  heading1: {
    fontSize: 24,
    fontWeight: 'bold',
    color: Colors.textPrimary,
  },
  body1: {
    fontSize: 16,
    color: Colors.textPrimary,
  },
  // ...
};

	•	목적: UI 통일, 유지보수 용이성

3.2 스페이싱 (Should)

export const Spacing = {
  xs: 4,
  sm: 8,
  md: 16,
  lg: 24,
  // ...
};

	•	목적: 레이아웃 간격 일관성

3.3 공통 컴포넌트 (Must)

// in RN: app/components/CommonButton.js
import React from 'react';
import {TouchableOpacity, Text, StyleSheet} from 'react-native';
import {Colors, Typography} from '../config';

export default function CommonButton({label, onPress}) {
  return (
    <TouchableOpacity style={styles.button} onPress={onPress}>
      <Text style={styles.text}>{label}</Text>
    </TouchableOpacity>
  );
}

const styles = StyleSheet.create({
  button: {
    backgroundColor: Colors.primary,
    padding: 16,
    borderRadius: 8,
  },
  text: {
    ...Typography.body1,
    color: 'white',
  },
});

	•	목적: 재사용 가능한 UI 요소, 중복 코드 방지

⸻

4. 코드 품질

4.1 네이밍 (Must)
	•	함수명: 동사+명사 (fetchUserData, saveOrder)
	•	상태/Hook: use prefix(useUserState)
	•	목적: 직관적 가독성

4.2 상태 관리 (Should)
	•	React Native/웹 통일: Redux Toolkit, or React Context + Reducer
	•	목적: 디버깅, 예측 가능성
	•	맥락: 몰아치기 식 혼합 금지

4.3 에러 처리 (Must)
	•	API 호출 시 try-catch + 에러 메시지 표시
	•	앱 크래시 방지: RN ErrorBoundary, 웹 React ErrorBoundary 활용
	•	목적: 안전한 사용자 경험

⸻

5. 멀티 에이전트 협업 (Agent AI) 지침

플샵은 PM 에이전트를 중심으로 Designer, Frontend, Backend, AIEngineer 등 역할별 Agent가 협업하는 구조를 취할 수 있습니다. 에이전트가 코드/디자인을 생성할 때도 이 문서의 규칙(폴더 구조, 파일명, 디자인 시스템)을 준수해야 합니다.

5.1 에이전트 설정 (Must)
	1.	PM Agent
	•	요청/요구사항 관리, 전체 일정/우선순위 조정
	•	모든 산출물(디자인, 코드 등)이 본 문서 규칙 준수 여부 최종 확인
	2.	Designer Agent
	•	색상/텍스트/간격은 colors.js, typography.js, spacing.js 등 디자인 시스템 참조
	•	컴포넌트 설계 시 재사용 가능성을 우선 고려
	3.	Frontend Agent
	•	React Native/React 파일명 규칙(스크린, 컴포넌트) 준수
	•	전역 스타일/테마(colors.js, typography.js) 불러와 사용
	4.	Backend Agent
	•	API 구조 설계 시 서비스 폴더(services/) 분리 원칙
	•	에러 처리(try-catch)와 의미 있는 함수/파일명 준수
	•	협의된 폴더 구조(React Native, 웹)와 충돌 없도록
	5.	AI Engineer Agent
	•	UI 코드는 Frontend Agent가, AI 모델 코드는 별도 디렉토리(ai/ or ml/) 등
	•	MCP(툴 연결)나 코드 생성 시 폴더 구조 준수 (e.g. ai/models/, ai/services/)

5.2 토론 및 산출물 (Should)
	•	A2A(AI-to-AI) 통신 시 PM Agent가 본 규칙 준수하도록 문맥 제공
	•	Designer Agent가 만든 UI 시안 파일명/구조 일관되게 → UI_Design_{컴포넌트이름}
	•	Frontend Agent가 생성한 코드 → GitHub MCP 커밋 시 commit message에 “code following ‘Cursor Rule’ folder structure” 등 명기

⸻

6. 협업/문서화

6.1 오류·작업 기록 (Must)
	•	errorlog.md, worklog.md
	•	AI 에이전트도 주요 오류(예: “폴더 구조 충돌”) 발생 시 PM Agent가 errorlog.md에 기록

6.2 문서-코드 동기화 (Must)
	•	디자인 시스템 변경 시, colors.js, typography.js 등 문서 업데이트
	•	API 변경 시, APIdoc.md 또는 Swagger 문서 업데이트
	•	AI Agent가 모델 구조 변경 시, mlDoc.md 업데이트 (선택)

6.3 코드 리뷰 (Must)
	•	AI 생성 코드도 사람 검수(긴급 예외 제외)
	•	PM Agent가 최종 승인

⸻

7. Cursor IDE 환경

7.1 단일 프로젝트 원칙 (Must)
	•	RN 앱: pplshop-rn/
	•	웹: pplshop-web/
	•	각각 별도 package.json. 공통 config는 workspace로 관리 가능
	•	새로 시작하기보다, 코드 변경 시 문서·구조 유지하며 업데이트

7.2 의존성 버전 관리 (Must)
	•	RN: react-native, react-navigation, etc. 버전 명시
	•	웹: react, next, react-router(CRA 시) 등 버전 명시
	•	lock 파일 유지(yarn.lock or package-lock.json)

7.3 문제 해결 프로세스 (Should)
	•	AI Agent 제안 솔루션 vs 사람 검증 병행
	•	Cursor 상에서 lint/compile/test 후, PM Agent에게 보고

⸻

8. Agent AI 세팅 예시 (권장)
	1.	PM Agent:
	•	인식한 요구사항 → Designer/Frontend/Backend/AI Agent에게 태스크 분배
	•	“ensure we follow Cursor Rule 1.0 folder naming” 포맷으로 sub-agents prompt
	2.	Designer Agent:
	•	“Given the design system (colors.js, typography.js), create new landing screen design.”
	•	산출물: Figma link or local asset naming
	3.	Frontend Agent:
	•	“Create a new screen in app/screens/MainScreen.js using Colors.primary for the header.”
	•	GitHub MCP push: “feat: add MainScreen following Cursor Rule structure.”
	4.	Backend Agent:
	•	“Implement userService.js in services/ folder.”
	•	Return code snippet or commit
	5.	AIEngineer Agent (선택):
	•	“Place YOLO model code in ai/models/, inference script in ai/services/.”
	•	Return or commit

목적: AI 에이전트들도 본 가이드 준수. PM Agent가 최종 승인 후 머지.

⸻

9. 프로젝트 규모별 적용 가이드

소규모 (Must)
	1.	기본 폴더 구조, 파일명, 색상/타이포 상수
	2.	에러 로그, 작업 로그 유지
	3.	1명 이상 코드리뷰

중규모 (Should)
	1.	상태 관리(Redux/Context)
	2.	공통 컴포넌트 적극 활용
	3.	MCP(디자인, GitHub 등) 연동
	4.	AI 멀티에이전트 일부 도입

대규모 (May)
	1.	Clean Architecture or 모듈화 아키텍처
	2.	CI/CD 파이프라인 + Automated Testing
	3.	고급 성능 최적화 / 국제화(i18n)
	4.	AI 멀티에이전트 풀 협업

⸻

결론

본 Cursor Rule은 플샵(PPLShop) 프로젝트의 React Native + 웹 환경에서 코드 구조·디자인 시스템·협업 프로세스를 표준화하는 가이드입니다. 기존 FMG 방식(Flutter) 대신, RN/React에 맞게 재정비했으며, 멀티 에이전트 AI(역할별 에이전트) 협업을 지원하도록 규칙을 확장했습니다.
	•	핵심(Must): 표준 폴더 구조, 디자인 상수, 파일명 규칙, 문서화, 코드 리뷰
	•	권장(Should): 상태 관리 패턴 통일, 스페이싱/테마 적극 활용, MCP 연동, 문서 자동화
	•	선택(May): 아키텍처 확장, 고급 CI/CD, AI Engineer 파트 추가 등

문서 버전
	•	버전: 1.0.0 (React Native + Web + Multi-Agent edition)
	•	최종 업데이트: 2023-11-21
	•	다음 검토 예정일: 2024-05-21

중요: 이 문서는 “엄격한 규칙집”이 아니라 “살아있는 가이드”입니다. 모든 팀원이 목적과 맥락을 이해하고, 필요에 따라 합리적 예외를 적용하거나 개선 제안을 통해 프로젝트와 함께 성장하는 문화가 바람직합니다.